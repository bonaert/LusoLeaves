// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter, Header, Parser, absDate, fs,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  Header = require('./header');

  fs = require('fs');

  absDate = function(year, month, date) {
    var pad;
    pad = function(num) {
      var norm;
      norm = Math.abs(Math.floor(num));
      if (norm < 10) {
        return norm = '0' + norm;
      } else {
        return norm = '' + norm;
      }
    };
    return new Date(year + '-' + pad(month) + '-' + pad(date) + 'T00:00:00Z');
  };

  Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(filename, options) {
      this.filename = filename;
      this.options = options;
      this.parseField = bind(this.parseField, this);
      this.parseRecord = bind(this.parseRecord, this);
      this.parse = bind(this.parse, this);
      this.options = this.options || {};
    }

    Parser.prototype.parse = function() {
      this.emit('start', this);
      this.header = new Header(this.filename);
      this.header.parse((function(_this) {
        return function(err) {
          var sequenceNumber;
          _this.emit('header', _this.header);
          sequenceNumber = 0;
          return fs.readFile(_this.filename, function(err, buffer) {
            var loc;
            if (err) {
              throw err;
            }
            loc = _this.header.start;
            while (loc < (_this.header.start + _this.header.numberOfRecords * _this.header.recordLength) && loc < buffer.length) {
              _this.emit('record', _this.parseRecord(++sequenceNumber, buffer.slice(loc, loc += _this.header.recordLength)));
            }
            return _this.emit('end', _this);
          });
        };
      })(this));
      return this;
    };

    Parser.prototype.parseRecord = function(sequenceNumber, buffer) {
      var field, fn, i, len, loc, record, ref;
      record = {
        '@sequenceNumber': sequenceNumber,
        '@deleted': (buffer.slice(0, 1))[0] !== 32
      };
      loc = 1;
      ref = this.header.fields;
      fn = (function(_this) {
        return function(field) {
          return record[field.name] = _this.parseField(field, buffer.slice(loc, loc += field.length));
        };
      })(this);
      for (i = 0, len = ref.length; i < len; i++) {
        field = ref[i];
        fn(field);
      }
      return record;
    };

    Parser.prototype.parseField = function(field, buffer) {
      var dd, emptyVal, mm, value, yy;
      emptyVal = this.options.emptyVal || null;
      value = (buffer.toString('utf-8')).replace(/^\x20+|\x20+$/g, '');
      switch (field.type) {
        case 'C':
          value = value || emptyVal;
          break;
        case 'N':
        case 'F':
          value = parseFloat(value);
          if (isNaN(value)) {
            value = emptyVal;
          }
          break;
        case 'L':
          if (value === 'Y' || value === 'y' || value === 'T' || value === 't') {
            value = true;
          } else if (value === 'N' || value === 'n' || value === 'F' || value === 'f') {
            value = false;
          } else {
            value = emptyVal;
          }
          break;
        case 'D':
          yy = parseInt(buffer.slice(0, 4));
          mm = parseInt(buffer.slice(4, 6));
          dd = parseInt(buffer.slice(6, 8));
          if (isNaN(yy)) {
            value = emptyVal;
          } else {
            value = absDate(yy, mm, dd);
          }
          break;
        default:
          value = value || emptyVal;
      }
      return value;
    };

    return Parser;

  })(EventEmitter);

  module.exports = Parser;

}).call(this);
